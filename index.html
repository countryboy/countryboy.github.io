<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2">






<meta name="description" content="How many times must a man look up,Before he can see the sky">
<meta property="og:type" content="website">
<meta property="og:title" content="Mountains">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mountains">
<meta property="og:description" content="How many times must a man look up,Before he can see the sky">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mountains">
<meta name="twitter:description" content="How many times must a man look up,Before he can see the sky">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'countryboy',
      author: 'countryboy'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/">


  <title> Mountains </title>
</head>

<body itemscope="" itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mountains</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/10/蚂蚁金服java后端电话面试/" itemprop="url">
                  蚂蚁金服java后端电话面试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-04-10T23:10:30+08:00" content="2019-04-10">
              2019-04-10
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/java学习-数据结构-线程-jvm-面试-蚂蚁金服/" itemprop="url" rel="index">
                    <span itemprop="name">java学习 数据结构 线程 jvm 面试 蚂蚁金服</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/04/10/蚂蚁金服java后端电话面试/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/10/蚂蚁金服java后端电话面试/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/04/10/蚂蚁金服java后端电话面试/" class="leancloud_visitors" data-flag-title="蚂蚁金服java后端电话面试">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在蚂蚁金服的前同事说他们那里很缺人，而我自己也想尝试一下，所以就有了被内推进行的一场蚂蚁金服的电话面试，但是因为在出差，准备不充足，第一次电话面试也有一点紧张，加上以前也确实做java不是很多，所以面试理所当然的挂了，下面重新梳理下当时的面试问题，继续努力了。</p>
</blockquote>
<h5 id="1-线程并发处理，除了加锁，还有那些方法？"><a href="#1-线程并发处理，除了加锁，还有那些方法？" class="headerlink" title="1.线程并发处理，除了加锁，还有那些方法？"></a>1.线程并发处理，除了加锁，还有那些方法？</h5><blockquote>
<p>答：没太理解这里面试官想要了解的内容，如果是并发的话就只有加锁，其他还有原子操作，副本和不可变变量。但是感觉这里面试官问的好像是锁的方式，除了synchronized,还有volatile和ReentrantLock。 </p>
</blockquote>
<h5 id="2-如何创建线程池？"><a href="#2-如何创建线程池？" class="headerlink" title="2.如何创建线程池？"></a>2.如何创建线程池？</h5><blockquote>
<p>答：这里其实也没太理解面试官的问题，感觉问的应该是ExecutorService的创建方式吧。java线程池一般都是ExecutorService来创建的，该类支持创建四种线程池，分别是：<br>1）newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。（线程最大并发数不可控制）<br>2）newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>3）newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。<br>4）newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br>但是他们底层其实都是通过ThreadPoolExecutor的构造函数来创建的。</p>
</blockquote>
<h5 id="3-线程池中核心线程数为10，最大线程数为30，任务队列为空，当前有10个线程，如果有一个新的任务，会如何处理"><a href="#3-线程池中核心线程数为10，最大线程数为30，任务队列为空，当前有10个线程，如果有一个新的任务，会如何处理" class="headerlink" title="3.线程池中核心线程数为10，最大线程数为30，任务队列为空，当前有10个线程，如果有一个新的任务，会如何处理"></a>3.线程池中核心线程数为10，最大线程数为30，任务队列为空，当前有10个线程，如果有一个新的任务，会如何处理</h5><blockquote>
<p>答：这个我当时回答错了，当时回答的是会直接新创建一个线程来执行，但是实际如果当线程池小于核心线程的时候，是会先将任务添加到任务队列中，只有当任务队列满了之后，并且最大线程大于核心线程，才会创建新的线程。具体的关系如下:<br>1).当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。<br>2).当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行<br>3).当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务<br>4).当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理<br>5).当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程<br>6).当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭 </p>
</blockquote>
<h5 id="4-dubbo服务器中，如果有一台服务挂掉了，是如果判断的？"><a href="#4-dubbo服务器中，如果有一台服务挂掉了，是如果判断的？" class="headerlink" title="4.dubbo服务器中，如果有一台服务挂掉了，是如果判断的？"></a>4.dubbo服务器中，如果有一台服务挂掉了，是如果判断的？</h5><blockquote>
<p>答：这里是我比较蠢了，我这里只回答了可能是心跳检测之类的，但是实际是长链接，zookeeper通过临时节点的方式来检查客户端是否存在，在服务注册的时候服务器会和zookeeper建立一个长链接，如果链接断开，那么就是服务挂掉了。网上搜索看到是使用Dubbo协议：采用NIO复用单一长连接，并使用线程池并发处理请求，减少握手和加大并发效率，在大文件传输时，单一连接会成为瓶颈</p>
</blockquote>
<h5 id="5-a转账给b的问题，如果是分布式的，该如何保证一致性？"><a href="#5-a转账给b的问题，如果是分布式的，该如何保证一致性？" class="headerlink" title="5.a转账给b的问题，如果是分布式的，该如何保证一致性？"></a>5.a转账给b的问题，如果是分布式的，该如何保证一致性？</h5><blockquote>
<p>答： 这里学习网上的答案，我理解有这么几个点，分布式系统因为cap理论，很难做到强一致性，所以一般都是根据业务场景来达到最终一致性。<br>分布式事务有这么几种解决方案：<br>1）两阶段提交：a.事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.b.事务协调器要求每个数据库提交数据。<br>2）补偿事务：主要是针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。a.Try 阶段主要是对业务系统做检测及资源预留b.Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。c.Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。<br>3）消息队列表：通过消息队列来完成事务的处理。每个节点处理完信息，并同时记录一笔消息的记录，每个节点完成了消息的业务处理内容，则记录完成，如果没有处理则可以进行失败消息重新处理或者重试，如果业务处理失败，则返回失败消息，进行事务回滚（这里没太看明白，如果要回滚，那是否要一直锁着资源？如果不是，那是否也需要实现补偿事务呢）。</p>
</blockquote>
<h5 id="6-什么条件会导致死锁，怎么解决？"><a href="#6-什么条件会导致死锁，怎么解决？" class="headerlink" title="6.什么条件会导致死锁，怎么解决？"></a>6.什么条件会导致死锁，怎么解决？</h5><blockquote>
<p>答：死锁指的是系统中两个以上的进程由于争夺资源，而相互等待的现象。<br>造成死锁的必要条件有1、互斥条件2、请求和保持条件3、不剥夺条件4、环路等待条件。<br>死锁的解决：<br>〈1〉打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。<br>〈2〉打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。<br>〈3〉打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。<br>〈4〉打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。</p>
</blockquote>
<h5 id="7-mysql怎么进行分库分表？"><a href="#7-mysql怎么进行分库分表？" class="headerlink" title="7.mysql怎么进行分库分表？"></a>7.mysql怎么进行分库分表？</h5><blockquote>
<p>答：这个问题因为我平时没有用过mysql数据库，所以没有回答，主要说了oracle的分区，但是其实原理应该是相通的，现在想象应该是可以回答的。一般分库可以按照读写分离来进行分库，分为主库和备用库，两个库之间再进行数据同步。也可以按照主键来垂直拆分，一般是按照取模的方式，来进行数据分库。表的话可以也可以进行垂直拆分和水平拆分，垂直拆分就是和分库一样，将表根据主键的进行范围或hash拆分，另外表也可以进行水平拆分，比如一个表有很多字段，其中有些字段是很经常用的，就可以单独拆成一个小表，来提交查询效率。</p>
</blockquote>
<h5 id="8-linux查询系统资源状态的命令有哪些？top命令有哪些参数"><a href="#8-linux查询系统资源状态的命令有哪些？top命令有哪些参数" class="headerlink" title="8.linux查询系统资源状态的命令有哪些？top命令有哪些参数"></a>8.linux查询系统资源状态的命令有哪些？top命令有哪些参数</h5><blockquote>
<p>答： 系统资源主要有cpu、内存、硬盘、网络，所以对应的命令有，top、free、df -h、ifconfig、netstat等。top的主要参数：<br>d：指定更新的间隔，以秒计算。<br>q：没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行。<br>c：显示进程完整的路径与名称。<br>S：累积模式，会将己完成或消失的子行程的CPU时间累积起来。<br>s：安全模式。<br>i：不显示任何闲置(Idle)或无用(Zombie)的行程。<br>n：显示更新的次数，完成后将会退出。 </p>
</blockquote>
<h5 id="9-java的内存模型？"><a href="#9-java的内存模型？" class="headerlink" title="9.java的内存模型？"></a>9.java的内存模型？</h5><blockquote>
<p>答： 当时回答的时候有点懵逼，没太听清楚他问的是什么，现在理解应该是问的java的jvm模型。分为方法区(Method Area)、java堆(Heap)、java栈(Stack)、程序计数器(PC Register)、本地方法栈(Native Method Stack)。其中堆内存又分为为新生代和旧生代，奇珍新生代又被划分为Eden空间和两块较小的Survivor空间。  </p>
</blockquote>
<h5 id="10-架构师需要关注哪些点？"><a href="#10-架构师需要关注哪些点？" class="headerlink" title="10.架构师需要关注哪些点？"></a>10.架构师需要关注哪些点？</h5><blockquote>
<p>答：这里我当时回答的时候主要从业务架构和技术架构两方面进行来回答，感觉一般业务架构可能更多的是产品经理的工作吧，面试技术岗位，主要还是需要关心技术层面的东西。现在会想的话，我觉得架构师应该至少具备这些能力。<br>1）解决复杂技术问题的能力，首先我觉得架构师应该一定是一个优秀的程序员，具备某一方面的专业能力。<br>2）具备全面的专业能力，我觉得架构师应该对项目开发的整个周期的技术都应该是了解的，比如开发、发布、测试、运维等各方面。<br>3）架构师要具备技术判断能力，能够进行技术，框架选择的抉择等。<br>4）架构师一定要对负责的系统有很全面和深刻的掌握，可以帮忙开发和设计人员来提高系统设计的可拓展性和稳定性。<br>5）架构师要具备很强的沟通能力，可以和产品、开发、测试进行流畅的沟通。<br>6）架构师也要具备一定的项目管理能力，对于项目要有整体的掌控，随时都保证项目的进度和风险在可控制的范围内。</p>
</blockquote>
<h5 id="11-java常用的集合接口有哪些？"><a href="#11-java常用的集合接口有哪些？" class="headerlink" title="11.java常用的集合接口有哪些？"></a>11.java常用的集合接口有哪些？</h5><blockquote>
<p>答： 集合主要有Map和Collection两大类。<br>Map主要有：<br>HashMap：最基本的Map类型，键值可以为null，是线程不安全的。<br>Hashtable：线程安全的Map，键值不能为空，但是因为实现了线程安全，所以效率较HashMap低。<br>ConcurrentHashMap：实现了线程安全的HashMap，根据key值，将一个HashMap分成了N个Segment，对每一段进行加锁，以此来提升了执行效率，默认是分成16段。<br>Collection主要有：<br>Vector：线程安全的集合。<br>ArrayList： 基于数组实现的，大小可变的数据集合。<br>LinkedList： 基于链式结构实现的集合，新增和删除的效率高于ArrayList。<br>HashSet： 基于HashMap实现的，所以不能有重复的数据。  </p>
</blockquote>
<h5 id="12-hashmap是线程安全的吗？"><a href="#12-hashmap是线程安全的吗？" class="headerlink" title="12.hashmap是线程安全的吗？"></a>12.hashmap是线程安全的吗？</h5><blockquote>
<p>答： 肯定是线程不安全的。  </p>
</blockquote>
<h5 id="13-java中创建线程有几种方式？"><a href="#13-java中创建线程有几种方式？" class="headerlink" title="13.java中创建线程有几种方式？"></a>13.java中创建线程有几种方式？</h5><blockquote>
<p>答：这里应该有三种，但是当时是忘了Callable的方式，通过前两种方式创建的线程是没有返回值的，Callable创建的可以有返回值。创建线程有三种方式，1.继承Thread类，并重写run方法2.定义runnable接口的实现类，并重写该接口的run()方法3.创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，创建Callable实现类的实例，使用FutureTask类来包装Callable对象，使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/05/成为JAVA顶尖程序员，先过了下面问题（解答一）/" itemprop="url">
                  成为JAVA顶尖程序员，先过了下面问题（解答一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-01-05T11:50:50+08:00" content="2019-01-05">
              2019-01-05
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/java学习-数据结构-线程-jvm/" itemprop="url" rel="index">
                    <span itemprop="name">java学习 数据结构 线程 jvm</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/01/05/成为JAVA顶尖程序员，先过了下面问题（解答一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/01/05/成为JAVA顶尖程序员，先过了下面问题（解答一）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/01/05/成为JAVA顶尖程序员，先过了下面问题（解答一）/" class="leancloud_visitors" data-flag-title="成为JAVA顶尖程序员，先过了下面问题（解答一）">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、数据结构与算法"><a href="#一、数据结构与算法" class="headerlink" title="一、数据结构与算法"></a>一、数据结构与算法</h4><ul>
<li>说一下几种常见的排序算法和分别的复杂度。<br><strong>解答：</strong></li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>时间复杂度（最好）</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>复杂性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>O(n^2）</td>
<td>O(n^2）</td>
<td>O(n^2）</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlog2n）</td>
<td>O(nlog2n)</td>
<td></td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2）</td>
<td>O(n^2）</td>
<td>O(n）</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog2n)</td>
<td>O(n^2）</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>直接选择排序</td>
<td>O(n^2）</td>
<td>O(n^2）</td>
<td>O(n^2）</td>
<td>O(1)</td>
<td>不稳定</td>
<td>简单</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(1)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(n)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(n+r)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
</tbody>
</table>
<p>其中堆排序和归并排序可以进行外排序<br>外排序的一种思路<br>1）按数据的大小对数据分K个块进行读取，并对每个文件块按一定的算法进行排序（一般为快速排序）<br>2）在内存维护一个K大小的堆，将每个文件的第一个元素读取进行，进行堆排序<br>3）将堆顶的元素拿出，放入临时数组，并将该堆顶元素所在文件的下一个元素拿出，继续维护该堆<br>4）当临时数据达到一定大小时，将临时数组写入磁盘文件，并清空数据<br>5）重复3、4两步操作，知道所有的元素都读取完  </p>
<ul>
<li>用JAVA写一个冒泡排序算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 递归实现快速排序算法</span><br><span class="line">	static void quickSort(int start, int end, int[] T) &#123;</span><br><span class="line">		if (T.length == 0 || start &gt;= end) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		int key = T[start];</span><br><span class="line">		int temp;</span><br><span class="line">		int i = start;</span><br><span class="line">		int j = end;</span><br><span class="line"></span><br><span class="line">		while (i != j) &#123;</span><br><span class="line">			for (; i != j; j--) &#123;</span><br><span class="line">				if (key &gt; T[j]) &#123;</span><br><span class="line">					temp = T[i];</span><br><span class="line">					T[i] = T[j];</span><br><span class="line">					T[j] = temp;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (j == i) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			for (; i != j; i++) &#123;</span><br><span class="line">				if (key &lt; T[i]) &#123;</span><br><span class="line">					temp = T[i];</span><br><span class="line">					T[i] = T[j];</span><br><span class="line">					T[j] = temp;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		quickSort(start, i - 1, T);</span><br><span class="line">		quickSort(i + 1, end, T);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>描述一下链式存储结构。<br><strong>解答：</strong>  <blockquote>
<p>每个节点由数据域和指针域组成，可以以O(1)的时间复杂度进行的删除和新增，但是查询的时间复杂度为O(n)，在逻辑上不必是连续的内存区域，可以比较方便的实现队列和栈。</p>
</blockquote>
</li>
<li>如何遍历一棵二叉树？  <blockquote>
<p> 可以使用先序遍历、中序遍历和后序遍历</p>
</blockquote>
</li>
<li><p>倒排一个LinkedList。<br><strong>解答:</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static public void linkedlistSort(LinkedList&lt;Integer&gt; T)&#123;</span><br><span class="line">		int linksize = T.size();</span><br><span class="line">		int temp ;</span><br><span class="line">		for (int i = 0; i &lt; linksize -1; i++) &#123;</span><br><span class="line">			for (int j = i +1; j &lt; linksize ; j++) &#123;</span><br><span class="line">				if(T.get(i) &lt; T.get(j) )</span><br><span class="line">				&#123;</span><br><span class="line">					temp = T.get(j);</span><br><span class="line">					T.set(j,T.get(i));</span><br><span class="line">					T.set(i,temp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用Java写一个递归遍历目录下面的所有文件。<br><strong>解答：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//遍历读取文件夹下的文件</span><br><span class="line">	public static List&lt;File&gt; getFileList(String strPath) &#123;</span><br><span class="line">        File dir = new File(strPath);</span><br><span class="line">        File[] files = dir.listFiles(); // 该文件目录下文件全部放入数组</span><br><span class="line">        String fileName = dir.getName();</span><br><span class="line">        if (files != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; files.length; i++) &#123;</span><br><span class="line">                if (files[i].isDirectory()) &#123; // 判断是文件还是文件夹</span><br><span class="line">                    String strFileName = files[i].getName();</span><br><span class="line">                    System.out.println(strFileName);</span><br><span class="line">                    getFileList(files[i].getAbsolutePath()); // 获取文件绝对路径</span><br><span class="line">                &#125; else &#123; </span><br><span class="line">                    String strFileName = files[i].getName();</span><br><span class="line">                    System.out.println(&quot;    ---&quot; + strFileName);</span><br><span class="line">                    filelist.add(files[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return filelist;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="二、JAVA基础"><a href="#二、JAVA基础" class="headerlink" title="二、JAVA基础"></a>二、JAVA基础</h4><ul>
<li>接口与抽象类的区别？<br><strong>解答：</strong>   <blockquote>
<p>接口和抽象类的相同点：<br>1）两个都是上层的抽象对象<br>2）接口和抽象类都不能被实例化<br>3）接口和抽象类都可以包含抽象方法<br>4）所有子类去继承抽象类和实现接口，如果要进行实例化，就必须实现他们全部的抽象方法<br>接口和抽象类的不同点：<br>1）接口只能包含抽象方法、抽象类可以有非抽象方法<br>2）一个子类只能继承一个抽象类，但是可以继承多个接口</p>
</blockquote>
</li>
<li>Java中的异常有哪几类？分别怎么使用？<br><strong>解答：</strong><blockquote>
<p>主要有Error和Exception两大类,Exception下又分为RuntimeException异常和非运行时异常。其中RuntimeException异常及其子类为可检查异常，其他异常为不可检查异常。<br>Error异常有：NoClassDeffoundError,InternalError,OutOfMemoryError,StackOverflowError,UnknownError<br>RuntimeException: NullPointerException,ClassCastException,ArithmeticException,ArrayIndexOutOfBoundException</p>
</blockquote>
</li>
<li>常用的集合类有哪些？比如List如何排序？<br><strong>解答：</strong><blockquote>
<p>集合主要有Map和Collection两大类。<br>Map主要有：<br>HashMap：最基本的Map类型，键值可以为null，是线程不安全的。<br>Hashtable：线程安全的Map，键值不能为空，但是因为实现了线程安全，所以效率较HashMap低。<br>ConcurrentHashMap：实现了线程安全的HashMap，根据key值，将一个HashMap分成了N个Segment，对每一段进行加锁，以此来提升了执行效率，默认是分成16段。<br>Collection主要有：<br>Vector：线程安全的集合。<br>ArrayList： 基于数组实现的，大小可变的数据集合。<br>LinkedList： 基于链式结构实现的集合，新增和删除的效率高于ArrayList。<br>HashSet： 基于HashMap实现的，所以不能有重复的数据。  </p>
</blockquote>
</li>
<li>ArrayList和LinkedList内部的实现大致是怎样的？他们之间的区别和优缺点？<br><strong>解答：</strong>  <blockquote>
<p>ArrayList是基于数组实现的，LinkedList是基于链式结构实现的，所以ArrayList查找效率更高，LinkedList进行新增和删除的效率更高。</p>
</blockquote>
</li>
<li>内存溢出是怎么回事？请举一个例子？<br><strong>解答：</strong>  <blockquote>
<p>内存溢出是因为JVM没有可以分配的内存空间了，主要有PermGen space不足和Java heap space不足，PermGen space空间不够，主要是引用的class太多;堆空间不足，可能是由于内存泄露，或者是创建了较多的大对象，并没有及时释放。</p>
</blockquote>
</li>
<li>==和equals的区别？<br><strong>解答：</strong>  <blockquote>
<p>==比较的是引用地址，equals比较的是他们的值，一般来说，对于基本数据类型来说，==和uquals比较的结果是一样的</p>
</blockquote>
</li>
<li>hashCode方法的作用？<br><strong>解答：</strong>  <blockquote>
<p>hashCode是JAVA的基类Object实现的一个方法，可以理解为对一个JAVA对象的Hash编码之后的一个整型数值，在HashMap中，就是基于hashCode值来进行存储数据的。</p>
</blockquote>
</li>
<li>NIO是什么？适用于何种场景？<br><strong>解答：</strong><blockquote>
<p>是非阻塞的IO，管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征。<br>如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候用NIO处理数据可能是个很好的选择。<br>而如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更合适。使用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作比较来权衡选择。</p>
</blockquote>
</li>
<li>HashMap实现原理，如何保证HashMap的线程安全？<br><strong>解答：</strong><blockquote>
<p>HashMap是基于数组和链式来实现的一个数据结构，初始的数组大小为16，负载因子为0.75，HashMap是使用hashCode来和数据的大小来进行运算来获取它在数组中的位置的，当两个key的hashCode值一样，那么就会使用使用链式来存储在位置的数据，当HashMap的大小超过数据大小*负载因子大小的容量，那么就会进行扩容和rehashing，将HashMap中的数据重新调整位置。保证HashMap的线程安全可以使用synchronized关键字，或者lock对象，或者直接使用ConcurrentHashMap来保证线程安全。</p>
</blockquote>
</li>
<li>JVM内存结构，为什么需要GC？<br><strong>解答：</strong> <blockquote>
<p>分为方法区(Method Area)、java堆(Heap)、java栈(Stack)、程序计数器(PC Register)、本地方法栈(Native Method Stack)。GC主要指的是JVM的堆内存空间回收，堆的内存有点类似内存池的概念，JAVA每次新建对象的时候都去申请，当使用完之后就有JVM来进行GC操作，这样可以使每次使用内存不用都向操作系统申请，使用完之后，或者使用多次时候，保证内存空间都能够被及时释放和清理。</p>
</blockquote>
</li>
<li>NIO模型，select/epoll的区别，多路复用的原理<br><strong>解答：</strong><br>1.支持一个进程所能打开的最大连接数  </li>
</ul>
<table>
<thead>
<tr>
<th>select</th>
<th style="text-align:left">单个进程所能打开的最大链接数由FD_SETSIZE宏定义，其大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步测试</th>
</tr>
</thead>
<tbody>
<tr>
<td>epoll</td>
<td style="text-align:left">虽然链接数目有限制，但是很大，1G内存的机器上可以打开10万左右的链接，2G内存的机器可以打开20万左右</td>
</tr>
</tbody>
</table>
<p>2.FD剧增后带来的IO效率问题</p>
<table>
<thead>
<tr>
<th>select</th>
<th style="text-align:left">因为每次调用都会对链接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”</th>
</tr>
</thead>
<tbody>
<tr>
<td>epoll</td>
<td style="text-align:left">因为epoll内核中是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有select的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题</td>
</tr>
</tbody>
</table>
<p>3.消息传递方式</p>
<table>
<thead>
<tr>
<th>select</th>
<th style="text-align:left">内核需要将消息传递到用户空间，都需要内核拷贝动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>epoll</td>
<td style="text-align:left">epoll通过内核和用户空间共享一块内存来实现</td>
</tr>
</tbody>
</table>
<blockquote>
<p>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<ul>
<li>Java中一个字符占多少个字节，扩展再问int, long, double占多少字节<br><strong>解答：</strong><br>1字节： byte , boolean<br>2字节： short , char<br>4字节： int , float<br>8字节： long , double</li>
<li>创建一个类的实例都有哪些办法？<br><strong>解答：</strong><br>有以下几种，1.new关键字；2.使用class.newInstance()；3.类实现clone接口；4.实现序列化接口的类，通过IO流反序列化读取一个类，获取实例。</li>
<li>final/finally/finalize的区别？<br><strong>解答：</strong><br>final可以用来修饰类，修饰类的时候表明，这个类不能被继承，也可以修改变量，修饰变量的时候表明这个变量不能被修改，也可以修改方法，表明这个方法不能被重写。<br>finnally是用来异常处理的时候使用的，当执行异常处理try，catch的时候，他们后面的的finnally块总是被执行到，不管这个异常有没有被执行。<br>finalize是在Object类中定义的一个方法，是在该对象执行垃圾回收前执行的方法，用来做一些垃圾回收前的清理工作，该方法可以被重写。</li>
<li>Session/Cookie的区别？<br><strong>解答：</strong><br>Session为服务器保证的用户的登录当前的会话信息，保存在应用服务器内存中，一般服务器重启后就会删除，用户保存用户当前的登录情况。cookie在浏览器存储用户数据的一种手段，可以设置有效期，在浏览器也可以获取，是一种不安全的用户数据存储手段，一般用户的会话管理会结合cookie和session一起来使用，当用户第一次登录，在服务器生成sessionId，返回后保存在cookie中，当再次请求之后，会在每次请求中带上当前用户的登录sessionId，一次来验证用户已经登录。</li>
<li>String/StringBuffer/StringBuilder的区别，扩展再问他们的实现？<br><strong>解答：</strong><br>String是字符串常量池，StringBuffer是可变的字符对象，StringBuilder和StringBuffer类似，但是StringBuffer对方法都用synchronized进行了修饰，所以StringBuffer是线程安全的，StringBuffer的效率较高一些。</li>
<li>Servlet的生命周期？<br><strong>解答:</strong><br>Servlet的生命周期包括实例化-》初始化-》服务-》销毁。<br>实例化：默认是web端第一次访问Servlet的时候实例化，如果在web.xml中配置了load-on-startup，则在服务启动的时候就创建。<br>初始化：调用init方法，为第一次访问的使用调用。<br>服务：调用service方法，为Servlet最终要的方法，通过Service方法来提供服务。<br>销毁：当服务停用的时候来进行销毁，此时会调用destory方法。  </li>
<li>如何用Java分配一段连续的1G的内存空间？需要注意些什么？<br><strong>解答:</strong><br>可以直接使用new对象来初始化数组，但是创建的空间大小一般只能为JVM设置的Xmx空间的一半，所以这样的话，Xmx至少要是2G空间。另外也可以使用sun.misc.Unsafe的来进行内存分配，这个和C语言中的malloc很像，是直接操作系统的内存空间，所以可以申请任意大小的内存空间，但是这样申请的内存需要自己进行垃圾回收，JVM无法进行回收。</li>
<li>Java有自己的内存回收机制，但为什么还存在内存泄露的问题呢？<br><strong>解答：</strong><br>因为通常我们认为的无效对象的方式的jvm判定的方式是不一样的，jvm通过判断该对象是否有被引用来进行内存回收，但是某些情况下，对象已经不被使用了，但是还依然有被引用,例如下面的例子，o对象每次处理完被置空了，但是由于依然被引用，所以不会被jvm回收<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector v = new  Vector( 10 );  </span><br><span class="line"> for  ( int  i = 1 ;i &lt; 100 ; i ++ )&#123;  </span><br><span class="line"> Object o = new  Object();  </span><br><span class="line"> v.add(o);  </span><br><span class="line"> o = null ;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>什么是java序列化，如何实现java序列化?(写一个实例)？<br><strong>解答：</strong><blockquote>
<p>序列化是一种对象持久化的手段,通过java序列化，可以将是JAVA在JVM重启后被重新加载该对象，除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。<br><strong>序列化及反序列化相关知识</strong><br>1、在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。<br>2、通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化<br>3、虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）<br>4、序列化并不保存静态变量。<br>5、要想将父类对象也序列化，就需要让父类也实现Serializable 接口。<br>6、Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。<br>7、服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p>
</blockquote>
</li>
<li>String s = new String(“abc”);创建了几个 String Object?<br><strong>解答：</strong><blockquote>
<p>2个，使用引号“”加字符的方式，也会创建一个String Object，然后以new方式去创建String的时候，会新建一个String Object。</p>
</blockquote>
<h4 id="三、JVM"><a href="#三、JVM" class="headerlink" title="三、JVM"></a>三、JVM</h4></li>
<li>JVM堆的基本结构。<br><strong>解答：</strong><blockquote>
<p>主要划分为新生代和旧生代，奇珍新生代又被划分为Eden空间和两块较小的Survivor空间。</p>
</blockquote>
</li>
<li>JVM的垃圾算法有哪几种？CMS垃圾回收的基本流程？<br><strong>解答：</strong><blockquote>
<p>主要有标记清除算法和复制算法，还有在此基础上的标记整理算法。<br>CMS垃圾回收主要分为以下四个阶段:<br>1).初始标记阶段<br>暂停所有的其他线程，并记录下直接与root相连的对象。<br>2).并发标记阶段<br>同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。<br>3).最终确认标记阶段<br>将上一阶段做了指针更新的区域和root合并为一个伪root集合，并对其做tracing。从而可以保证真正可达的对象一定被标记了。但同时也会产生一部分被标记为可达，但其实已经是不可达的区域，由于已经没有了到达这个区域的路径，所以并没有办法将它的标志位置为0，则造成了一个暂时的内存泄漏，但这部分空间会在下一次收集阶段被清扫掉。<br>4).并发清扫阶段<br>开启用户线程，同时GC线程开始对为标记的区域做清扫。这个过程要注意不要清扫了刚被用户线程分配的对象。一个小trick就是在这个阶段，将所有新分配的对象置为可达的。 </p>
</blockquote>
</li>
<li>JVM有哪些常用启动参数可以调整，描述几个？<br><strong>解答：</strong>  <blockquote>
<p>各主要JVM启动参数的作用如下：<br>-Xms：设置jvm内存的初始大小<br>-Xmx：设置jvm内存的最大值<br>-Xmn：设置新域的大小（这个似乎只对jdk1.4来说是有效的，后来就废弃了）<br>-Xss：设置每个线程的堆栈大小(也就是说,在相同物理内存下，减小这个值能生成更多的线程)<br>-XX：NewRatio:设置新域与旧域之比，如-XX：NewRatio=4就表示新域与旧域之比为1：4<br>-XX:NewSize：设置新域的初始值<br>-XX:MaxNewSize：设置新域的最大值<br>-XX:MaxPermSize：设置永久域的最大值<br>-XX:SurvivorRatio=n:设置新域中Eden区与两个Survivor区的比值。（Eden区主要是用来存放新生的对象，而两个Survivor区则用来存放每次垃圾回收后存活下来的对象）  </p>
</blockquote>
</li>
<li>如何查看JVM的内存使用情况？<br><strong>解答：</strong>  <blockquote>
<p>可以使用jmap程序、jstat程序、JDK自带的工具软件，比如jconsole或者jvisualVM,或者其他JVM内存查看和分析软件，比如 jprofiler。</p>
</blockquote>
</li>
<li>Java程序是否会内存溢出，内存泄露情况发生？举几个例子。<br><strong>解答：</strong><blockquote>
<p>会有内存溢出和泄露的情况。<br>主要有栈溢出：比如进行函数递归调用的时候没有出口。<br>堆溢出：主要是创建了大量大对象的引用，一般是对容器中添加了对象，或者对static变量进行对象的创建等。<br>方法区溢出：主要是创建了内存中加载了大量的class，可能是使用反射的方法创建的。<br>比如对于一些容器创建大量大的对象，或者对static变量进行赋值操作。</p>
</blockquote>
</li>
<li>你常用的JVM配置和调优参数都有哪些？分别什么作用？<br><strong>解答：</strong> <blockquote>
<p>堆设置<br>-Xms:初始堆大小<br>-Xmx:最大堆大小<br>-XX:NewSize=n:设置年轻代大小<br>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4<br>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5<br>-XX:MaxPermSize=n:设置持久代大小<br>收集器设置<br>-XX:+UseSerialGC:设置串行收集器<br>-XX:+UseParallelGC:设置并行收集器<br>-XX:+UseParalledlOldGC:设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC:设置并发收集器<br>垃圾回收统计信息<br>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename<br>并行收集器设置<br>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)<br>并发收集器设置<br>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。  </p>
</blockquote>
</li>
<li>JVM的内存结构？<br><strong>解答：</strong><blockquote>
<p>分为方法区(Method Area)、java堆(Heap)、java栈(Stack)、程序计数器(PC Register)、本地方法栈(Native Method Stack)。</p>
</blockquote>
</li>
<li>常用的GC策略，什么时候会触发YGC，什么时候触发FGC？<br><strong>解答：</strong><blockquote>
<p>常用的GC策略有串行&amp;并行、并行&amp;stop the world，压缩&amp;非压缩%COPY。YGC触发的条件：edn空间不足。    FGC触发的条件：1.old空间不足 2.perm空间不足 3.显示调用System.gc() ，包括RMI等的定时触发 4.YGC时的悲观策略 5.dump live的内存信息时(jmap –dump:live)。</p>
</blockquote>
<h4 id="四、多线程和并发"><a href="#四、多线程和并发" class="headerlink" title="四、多线程和并发"></a>四、多线程和并发</h4></li>
<li>如何创建线程？如何保证线程安全？<br><strong>解答：</strong><blockquote>
<p>创建线程有三种方式，1.继承Thread类，并重写run方法2.定义runnable接口的实现类，并重写该接口的run()方法3.创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，创建Callable实现类的实例，使用FutureTask类来包装Callable对象，使用FutureTask对象作为Thread对象的target创建并启动新线程。确保线程安全的方法有这几个：竞争与原子操作、同步与锁、可重入、过度优化volatile关键字。</p>
</blockquote>
</li>
<li>如何实现一个线程安全的数据结构<br><strong>解答：</strong><blockquote>
<p>使用volatile定义一个信号量，对共享资源进行信号量标记。</p>
</blockquote>
</li>
<li>HashMap在多线程环境下使用需要注意什么？为什么？<br><strong>解答：</strong><blockquote>
<p>需要注意数据同步问题，因为HashMap是非同步的数据结构，如果需要数据同步，可以使用Hashtable或者ConcurrentHashMap。</p>
</blockquote>
</li>
<li>Java程序中启动一个线程是用run()还是start()？<br><strong>解答：</strong><blockquote>
<p>如果是通过继承Thread类方式实现的线程，那么就使用start()方法来启动线程，如果是实现runnable接口的类，那么是通过run()方法来启动。</p>
</blockquote>
</li>
<li>什么是守护线程？有什么用？<br><strong>解答：</strong><blockquote>
<p>在JAVA中守护线程就是调用了SETDAEMON（）方法的线程，即后台线程.守护线程的作用是为非后台线程服务。</p>
</blockquote>
</li>
<li>什么是死锁？如何避免<br><strong>解答：</strong>  <blockquote>
<p>死锁指的是系统中两个以上的进程由于争夺资源，而相互等待的现象。<br><strong>造成死锁的必要条件</strong>有1、互斥条件2、请求和保持条件3、不剥夺条件4、环路等待条件。<br>死锁的解决：<br>〈1〉打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。<br>〈2〉打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。<br>〈3〉打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。<br>〈4〉打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。</p>
</blockquote>
</li>
<li>线程和进程的差别是什么？<br><strong>解答：</strong><blockquote>
<p>进行是操作系统分配资源的最小单位，线程是程序执行的最小单位</p>
</blockquote>
</li>
<li>ConcurrentHashMap的实现原理是？<br><strong>解答：</strong> <blockquote>
<p>ConcurrentHashMap是在HashMap的基础上，实现了线程安全，它通过分段锁的概念，区别于HashTbale，它并不是将所有数据都加锁，而是将整个数据分成了很多段来分别加锁，这样，在执行的执行的时候，如果不是自己数据所在的段，则不会加锁，以此提高了执行的效率。</p>
</blockquote>
</li>
<li>sleep和wait区别<br><strong>解答：</strong>   <blockquote>
<p>sleep是Thread的方法，调用之后只是暂时放弃cpu的执行给其他线程，但是线程依然持有对象锁，当指定的时间到了之后又会自动恢复运行状态；wait是Object的方法，当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，<br>获取对象锁进入运行状态。</p>
</blockquote>
</li>
<li>notify和notifyAll区别<br><strong>解答：</strong>   <blockquote>
<p>notify是随机唤醒一个处于wait状态的线程，notifyAll是唤醒全部的处于wait状态的线程，此时所有的线程都会处于该对象的锁池中，可以参与该对象锁的竞争。</p>
</blockquote>
</li>
<li>volatile关键字的作用<br><strong>解答：</strong> <blockquote>
<p>volatile具有两大特性：禁止重排序、内存可见性，可以保证在程序执行的过程中，永远获取到内存中最新的数据。</p>
</blockquote>
</li>
<li>ThreadLocal的作用与实现<br><strong>解答：</strong> <blockquote>
<p>作用：保存每个线程自己的局部变量，避免和其他线程产生冲突。<br>实现：在ThreadLocal内部，有一个Map来维护每个线程自己的副本。</p>
</blockquote>
</li>
<li>两个线程如何串行执行<br><strong>解答：</strong> <blockquote>
<p>可以使用Thread的join方法，分为a,b两个线程，可以在线程b执行的时候，使用a.join()方法，等待a执行完，再执行b，就可以达到串行执行的效果，也可以定义个volatile标记变量，来标记是否有线程执行中，如果有线程执行中，则等待线程a执行。</p>
</blockquote>
</li>
<li>上下文切换是什么含义<br><strong>解答：</strong> <blockquote>
<p>指多个线程运行时，cpu切换当前正在运行的线程，会切换当前线程的方法区和计数器等。</p>
</blockquote>
</li>
<li>可以运行时kill掉一个线程吗？<br><strong>解答：</strong> <blockquote>
<p>可以，可以设置一个标志位，让线程正常运行结束run方法，正常结束，也可以使用stop方法，强制结束线程；或者使用interrupt()方法，让线程中断。</p>
</blockquote>
</li>
<li>什么是条件锁、读写锁、自旋锁、可重入锁？<br><strong>解答：</strong> <blockquote>
<p>条件锁：每一个Lock可以有任意数据的Condition对象，Condition是与Lock绑定的，所以就有Lock的公平性特性：如果是公平锁，线程为按照FIFO的顺序从Condition.await中释放，如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。<br>读写锁：Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。<br>Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock.<br>自旋锁：自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。<br>可重入锁：可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。  </p>
</blockquote>
</li>
<li>线程池ThreadPoolExecutor的实现原理？<br><strong>解答：</strong>   <blockquote>
<p>线程池ThreadPoolExecutor通过维护一个核心线程池，将需要执行的任务加入进来，如果当前有空闲进程，就直接使用空闲线程执行，否则，将该任务放入排队队列，等待有空闲线程。该知识点以后准备通过阅读源码的方式学习。下面罗列一些重要的知识点。<br>corePoolSize：线程池中的核心线程数；<br>workQueue：任务的阻塞队列，缓存将要执行的Runnable任务，由各线程轮询该任务队列获取任务执行。<br>ThreadFactory: 线程工厂,用来创建线程的类。<br>Worker：线程池中的线程。<br>Task：线程池中的任务。<br>RejectedExecutionHandler： 线程池的拒绝策略。</p>
</blockquote>
<div></div></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/01/angular_bootstrap/" itemprop="url">
                  angularJS加载原理和双向数据绑定学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-01T16:07:50+08:00" content="2017-05-01">
              2017-05-01
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/WEB前端开发/" itemprop="url" rel="index">
                    <span itemprop="name">WEB前端开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/01/angular_bootstrap/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/01/angular_bootstrap/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/05/01/angular_bootstrap/" class="leancloud_visitors" data-flag-title="angularJS加载原理和双向数据绑定学习笔记">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h6 id="最近因为要开发APP项目，是使用angular来开发的，所以需要学习angular，但是对于angular的加载原理和双向绑定一直是一知半解，所以下面是对这两个问题的学习。"><a href="#最近因为要开发APP项目，是使用angular来开发的，所以需要学习angular，但是对于angular的加载原理和双向绑定一直是一知半解，所以下面是对这两个问题的学习。" class="headerlink" title="最近因为要开发APP项目，是使用angular来开发的，所以需要学习angular，但是对于angular的加载原理和双向绑定一直是一知半解，所以下面是对这两个问题的学习。"></a>最近因为要开发APP项目，是使用angular来开发的，所以需要学习angular，但是对于angular的加载原理和双向绑定一直是一知半解，所以下面是对这两个问题的学习。</h6></blockquote>
<h4 id="angularjs的加载原理"><a href="#angularjs的加载原理" class="headerlink" title="angularjs的加载原理"></a>angularjs的加载原理</h4><ol>
<li><strong>angular应用启动：</strong> angular也是作为普通的js被加载的，浏览器会在构建DOM元素时加载AngularJS库（如同正常加载任意JavaScript库）。当angular.js被取回时，浏览器会执行它，同时设置一个事件监听器来监听浏览器的DOMContentLoaded事件。当浏览器触发DOMContentLoaded事件时，Angular就开始工作。它首先寻找ng-app指令，如果浏览器在DOM中找到ng-app指令，它会为我们自动启动应用。(ps:如果没有找到这个指令，也可以通过手动执行angular的bootstrap()方法来启动angular）</li>
<li><strong>创建$rooeScope和编译DOM</strong> 一旦应用程序加载完成，$injector就会在应用程序的$rootScope旁边创建$compile服务。$rootScope创建后， $compile服务就会接管它。 它会将$rootScope与现有的DOM连接起来，<br>然后从将ng-app指令设置为祖先的地方开始编译DOM。</li>
<li><strong>创建实时视图</strong><br>$compile服务通过遍历DOM树的方式查找有声明指令的DOM元素。当碰到带有一个或多个<br>指令的DOM元素时，它会排序这些指令（基于指令的priority优先级），然后使用$injector服务查找和收集指令的compile函数并执行它。<br>指令中的compile函数会在适当的时候处理所有DOM转换或者内联模板，如同创建模板的<br>副本。<br>// 返回一个链接函数 var linkFunction = $compile(appElement);<br>// 调用链接函数，将$rootScope附加给DOM元素 linkFunction($rootScope);<br>每个节点的编译方法运行之后，$compile服务就会调用链接函数。这个链接函数为绑定了封闭作用域的指令设置监控。这一行为会创建实时视图。<br>最后，在$compile服务完成后， AngularJS运行时就准备好了。<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3></li>
<li><strong>事件监听：</strong> 在标准的浏览器流程中，事件循环会等待事件执行（比如鼠标移动、点击、按键等）。当这些事件发生时，它们会被放到浏览器的事件队列中。如果有函数处理程序对事件作出响应，浏览器就会将event对象作为参数来调用这些事件处理程序。<br>ele.addEventListener(‘click’, function(event) {});<br>Angular中对事件循环做了一点增强，并且Angular还提供了自己的事件循环。指令自身会注册事件监听器，因此当事件被触发时，指令函数就会运行在AngularJS的$digest循环中。</li>
<li><strong>$digest循环</strong>：Angular的事件循环被称作$digest循环。这个$digest循环由两个小型的循环组成，分别是evalAsync循环和$watch列表。</li>
<li><strong>$watch列表：</strong><br>$scope对象上的$watch方法会给Angular事件循环内的每个$digest调用装配一个脏值检查。<br>如果在表达式上检测到变化， Angular总是会返回$digest循环。<br>$watch函数本身接受两个必要参数和一个可选的参数：<br> watchExpression<br>watchExpression可以是一个作用域对象的属性，或者是一个函数。在$digest循环中的每<br>个$digest调用都会涉及它。如果watchExpression是一个字符串，Angular会在$scope上下文中对它求值。如果它是一个函数，那么Angular会认为它会返回应该被监控的值。<br> listener/callback<br>作为回调的监听器函数，它只会在watchExpression的当前值与先前值不相等（除了首次运行初始化期间）时调用。<br> objectEquality（可选）<br>objectEquality是一个进行比较的布尔值，用来告诉Angular是否检查严格相等。<br>$watch函数会给监听器返回一个注销函数，我们可以调用这个注销函数来取消Angular对当前值的监控。</li>
<li><strong>$evalAsync方法</strong><br>$evalAsync()方法是一种在当前作用域上调度表达式在未来某个时刻运行的方式。 $digest循环运行的第二个操作是执行$$asyncQueue。可以使用$evalAsync()方法访问这个工作队列。$digest循环期间，贯穿脏值检查生命周期的每个循环之间的队列都是空的，这意味着使用$evalAsync来调用任何函数都会发生两件事情。<br> 函数会在这个方法被调用的某个时刻之后执行。<br> 表达式求值之后至少会执行一次$digest循环。<br>$evalAsync()方法接受一个唯一参数：<br> expression（字符串/函数）<br>这个表达式便是我们想要在当前作用域上执行的东西。如果传入一个字符串， Angular将会<br>在当前作用域上使用$eval求值该表达式。<br>如果传入的是一个函数， Angular将会使用传递给这个函数的scope对象执行函数求值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$scope.$evalAsync(&apos;attribute&apos;,</span><br><span class="line">function(scope) &#123;</span><br><span class="line">scope.foo = &quot;Executed&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用$evalAsync时要注意的一些细节。<br> 如果指令直接调用$evalAsync()，它会在Angular操作DOM之后、浏览器渲染之前运行。<br> 如果控制器调用$evalAsync()，它也会在Angular操作DOM之后、浏览器渲染之前运行 （永远不要使用$evalAsync()来约定事件的顺序）。   无论何时，在Angular中，只要你想要在一个行为的执行上下文外部执行另一个行为，就应该使用$evalAsync()函数。（关于$evalAsync队列和$evalAsync()函数，我是很困惑的，感觉像是在$digest循环执行前的一个异步队列，很难搞懂它的作用，看了这篇博<a href="http://blog.csdn.net/dm_vincent/article/details/51607018" target="_blank" rel="noopener"> [AngularJS面面观] 5. scope中的两个异步方法 - $applyAsync以及$evalAsync</a>，感觉清楚了很多，为了提高$digest循环的效率，所以有了$evalAsync队列，当有$evalAsync异步事件事，angular会在$evalAsync队列清空之后，再去做$watch检查和页面渲染，这样一个场景就是，当有多个$http请求时，不用每次请求回来就做一次页面渲染，另外这样也可以避免页面的闪烁）</p>
<ol start="5">
<li><strong>什么时候触发$digest循环：</strong><br>通常可以依赖于Angular提供的可用于视图中的任意指令来调用$apply()。所有ng-[event]指令（比如ng-click、 ng-keypress）都会调用$apply()。<br>此外还可以依赖于一系列Angular内置的服务来调用$digest()。比如$http服务会在XHR请<br>求完成并触发更新返回值（promise）之后调用$apply()。<br>无论何时我们手动处理事件，使用第三方框架（比如jQuery、 Facebook API） ，或者调用setTimeout()，都可以使用$apply()函数让Angular返回$digest循环。<br>（PS:在开发中我经常遇到$scope控制器变量改变了，但是视图没有变化的情况，看来是使用了非ng的指令或服务，所以需要自己手动来触发）<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
</ol>
<ul>
<li>angular的加载主要是通过监听浏览器的DOMContentLoaded事件、通过编译DOM结构来创建模板DOM、和创建实时视图来完成的。</li>
<li>angular的双向数据绑定主要是通过事件监听和脏值检查来完成的。<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4></li>
<li><strong>DOM文档加载的步骤为</strong></li>
</ul>
<ol>
<li>解析HTML结构。</li>
<li>加载外部脚本和样式表文件。</li>
<li>解析并执行脚本代码。</li>
<li>DOM树构建完成。（DOMContentLoaded事件）</li>
<li>加载图片等外部文件。</li>
<li>页面加载完毕。（load事件）</li>
</ol>
<ul>
<li><strong>手动启动一个AngularJS应用</strong><br>要手动启动一个AngularJS应用，可以使用Angular的bootstrap()方法。在一些罕见的情况<br>下手动启用应用程序是有意义的。例如，想要在某个其他库的代码运行之后，或者在运行时动态创建元素时，启动AngularJS应用。要想手动启动应用，可以像下面这样启动它：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var newElement =document.createElement(&quot;div&quot;);  </span><br><span class="line">angular.bootstrap(newElement, [&apos;myApp&apos;]);&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h4><p>书本 《AngularJS权威教程》/（美）勒纳（Lerner,A.）著；赵望野，徐飞，何鹏飞译. – 北京：人民邮电出版社，2014.8</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/JAVA WEB学习笔记——JSP学习/" itemprop="url">
                  JAVA WEB学习笔记——JSP学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-26T18:10:30+08:00" content="2016-11-26">
              2016-11-26
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/WEB开发/" itemprop="url" rel="index">
                    <span itemprop="name">WEB开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/26/JAVA WEB学习笔记——JSP学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/26/JAVA WEB学习笔记——JSP学习/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/26/JAVA WEB学习笔记——JSP学习/" class="leancloud_visitors" data-flag-title="JAVA WEB学习笔记——JSP学习">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="JSP是什么"><a href="#JSP是什么" class="headerlink" title="JSP是什么"></a>JSP是什么</h4><p>JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML（标准通用标记语言的子集）文件(*.htm,*.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。</p>
<h4 id="JSP的内置类以及作用范围"><a href="#JSP的内置类以及作用范围" class="headerlink" title="JSP的内置类以及作用范围"></a>JSP的内置类以及作用范围</h4><ul>
<li><strong>jsp共有以下九大内置类，其中比较常用的是pageContext、request、response、session、application类</strong>  </li>
</ul>
<table>
<thead>
<tr>
<th>内置对象</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>javax.servlet.ServletRequest</td>
<td>得到用户的请求信息  </td>
</tr>
<tr>
<td>response</td>
<td>javax.servlet.SrvletResponse</td>
<td>服务器向客户端的回应信息</td>
</tr>
<tr>
<td>pageContext</td>
<td>javax.servlet.jsp.PageContext</td>
<td>JSP的页面容器</td>
</tr>
<tr>
<td>session</td>
<td>javax.servlet.http.HttpSession</td>
<td>用来保存每一个用户的信息</td>
</tr>
<tr>
<td>application</td>
<td>javax.servlet.ServletContext</td>
<td>表示所有用户的共享信息</td>
</tr>
<tr>
<td>config</td>
<td>javax.servlet.ServletConfig</td>
<td>服务器配置，可以取得初始化参数</td>
</tr>
<tr>
<td>out</td>
<td>javax.servlet.jsp.JspWriter</td>
<td>页面输出</td>
</tr>
<tr>
<td>page</td>
<td>javax.lang.Object</td>
<td>表示从页面中表示出来的一个Servlet实例</td>
</tr>
<tr>
<td>exception</td>
<td>javax.lang.Throwable</td>
<td>表示JSP页面所发生的夜场，在错误页中才起作用</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>JSP的内置类有4中属性的保存范围</strong><br>page: 只在一个页面中保存属性，跳转之后无效<br>request：只在一次请求中保存属性，服务器跳转后依然有效<br>session：在一次会话范围中保存，无论何种跳转都可以适用，但是新开浏览器无法使用<br>application：在整个服务器上保存，所有用户都可以使用</li>
</ul>
<h4 id="JSP开发的一些问题"><a href="#JSP开发的一些问题" class="headerlink" title="JSP开发的一些问题"></a>JSP开发的一些问题</h4><h5 id="JSP页面的客户端跳转和服务器跳转"><a href="#JSP页面的客户端跳转和服务器跳转" class="headerlink" title="JSP页面的客户端跳转和服务器跳转"></a>JSP页面的客户端跳转和服务器跳转</h5><ul>
<li><strong>客户端跳转</strong>：客户端跳转之后地址栏会变为新的地址，并且是在页面加载完之后才会跳转，跳转之后不会保存request的值，跳转方法有response.sendRedirect()、response.setHeader(“refresh”,”2;URL=index.jsp”)、超链接</li>
<li><strong>服务器跳转</strong>：服务器跳转属于内部跳转，跳转之后地址栏不会变，并且是到执行语句之后立即跳转，跳转之后可以获取request的值，跳转方法有<a href="jsp:forward" target="_blank" rel="noopener">jsp:forward</a>、request.getRequestDispatcher()</li>
</ul>
<h4 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h4><ul>
<li>Java EE是在Java SE基础上建立起来的用来进行企业级应用程序开发的一种标准开发构架，Java EE共有四种容器，Applet Container、Application Client Contain、Web Container和EJB Container。JSP是其中Web Container下的一种页面解决技术，在实际开发中，JSP通常和Servlet一起使用。</li>
<li>request对象是javax.servlet.http.HttpServlet接口的实例，所有客户端信息和其发送的请求信息都通过此对象获取；response对象是javax.servlet.http.HttpServletResponse接口的实例，该对象表示服务器端对客户端的回应，此接口可以完成设置头信息、客户端跳转、设置Cookie等操作；我的理解，JSP开发的过程就是对客户端的request请求处理后，以response返回的过程。</li>
<li>可以直接使用pageContext对象获取ServletRequset、ServletResponse、ServletConfig和ServletContext接口的实例。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/06/beinteresting/" itemprop="url">
                  如何成为一个有趣的人
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-06T23:01:30+08:00" content="2016-11-06">
              2016-11-06
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/生活/" itemprop="url" rel="index">
                    <span itemprop="name">生活</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/06/beinteresting/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/06/beinteresting/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/06/beinteresting/" class="leancloud_visitors" data-flag-title="如何成为一个有趣的人">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>有趣，是一辈子的春药，余生太长，做一个有趣的人！</p>
</blockquote>
<h4 id="丰富自己的性格标签"><a href="#丰富自己的性格标签" class="headerlink" title="丰富自己的性格标签"></a>丰富自己的性格标签</h4><ol>
<li><strong>拥有自己的独特的标签</strong>：世界上没有两片一模一样的树叶，同样，也没有完全一样的两个人，每个人都有自己的性格和特点，学会欣赏自己的特点，不管是生理上的或者是性格上的，欣赏自己，表现自己，那就是个有趣的开始了。</li>
<li><strong>独立思考，有想法，不人云亦云</strong>：一个有想法，有见解的人，总是受周围的人喜欢的，在平时的相处中，有很多人总是喜欢随众，附和他人，比如点餐的时候，喜欢说随便，讨论的时候附和他人，其实每个人都是平等的个体，我们要做的就是求同存异，大胆发表自己的意见，表达自己的个性，也是件有趣的事。</li>
<li><strong>做一个性情中人</strong>：令狐冲和杨过谁更有趣一些呢？我觉得令狐冲是更有趣的，可以坚持自己的原则，交友不在乎正邪之正，人生在世，大块喝酒，大块吃肉，为人豁达畅快，相反，杨过就显得有点冷冷冰冰了。</li>
</ol>
<h4 id="拥有广泛的兴趣爱好"><a href="#拥有广泛的兴趣爱好" class="headerlink" title="拥有广泛的兴趣爱好"></a>拥有广泛的兴趣爱好</h4><ol>
<li><strong>拥有广泛的知识面</strong>： 我觉得一个见多识广，知识渊博的人，这真的是非常有趣了，在能各方面都有自己的见解和看法，和各行各业的人都可以侃侃而谈，可以随时随地的参与到大家的讨论中，知识渊博的人真的算是人群中的一盏明灯了，不仅可以点亮自己，还可以照耀他人。</li>
<li><strong>会一门乐器</strong>：我真的觉得会一门乐器真的是太重要，无论是在节目表演，还是自己打发时间，乐器都是绝对的利器，学习一门乐器，那么你就可以进入一个新的领域，人生开始变得不太一样。</li>
<li><strong>学习一些有趣的技能</strong>：厨艺、摄影、潜水、钓鱼、唱歌、跳舞、编程、打网球等</li>
<li><strong>去旅行吧</strong>：旅行绝对是一个可以使生活变得有趣的方式，因为的每一次旅行都是一个全新的开始，你将会遇到不同的人，见到不同的景色，欣赏到不同的美食，听到不同的故事。</li>
</ol>
<h4 id="认识更多有趣的朋友"><a href="#认识更多有趣的朋友" class="headerlink" title="认识更多有趣的朋友"></a>认识更多有趣的朋友</h4><ol>
<li><strong>和有趣的人交朋友</strong>： 我觉得有趣的人一定会有一些有趣的朋友，同时这些有趣的朋友使这个人更有趣。在九把刀的《等一个人咖啡中》，阿拓真的是一个非常有趣的，一个人看电影的社会大哥、做菜非常美味的金刀大婶、还有那个打电动非常厉害的流浪小孩，结交一群有趣的朋友，本身就是一件非常有趣的事。</li>
</ol>
<h4 id="对世界兴趣盎然"><a href="#对世界兴趣盎然" class="headerlink" title="对世界兴趣盎然"></a>对世界兴趣盎然</h4><ol>
<li><strong>勇敢尝试新的事物</strong>：对世界充满这好奇之心，去体验没有体验过的事情，去看没有见过的风景，去做没有做过的事情，我觉得未知的事物都是很有趣的，永远充满着好奇心，去发现未知的世界，这真是太有趣了。</li>
<li><strong>丰富的想象力和创造力</strong>：有趣本身就是与众不同，是和通常所不一样，试想一个新颖的段子，第一次说会让人眼前一亮，但是说的久了大家也会觉得了然无趣，有趣需要大胆的想象，不同的角度思考。</li>
</ol>
<hr>
<p>每一个有趣的人都是一个独立的世界，和这样的人接触，你不是将你的世界和他融合，他会为你打开一个新世界大门，在这个世界里你会感受到新奇，惊异，去欣赏他的世界，那么你们就拥有了两个世界。做一个有趣的人，去认识有趣的人，世界开始变得有趣起来！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/21/tomatowork/" itemprop="url">
                  番茄工作法使用小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-21T21:10:30+08:00" content="2016-10-21">
              2016-10-21
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/时间管理/" itemprop="url" rel="index">
                    <span itemprop="name">时间管理</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/21/tomatowork/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/21/tomatowork/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/21/tomatowork/" class="leancloud_visitors" data-flag-title="番茄工作法使用小结">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>因为我一直是个不怎么能专注的人，尤其是做一些我不是感情兴趣，或者说短期收益不大，不能及时得到正反馈的事，例如读书，练字，健身这些事，我都是很难坚持，但是最近接触到番茄工作法使我受益匪浅，感觉就是为了我这种人而定制的工作方法，所以来简单介绍下番茄工作法和使用，希望自己可以改进和坚持。</p>
</blockquote>
<h4 id="1-为什么需要番茄工作？"><a href="#1-为什么需要番茄工作？" class="headerlink" title="1.为什么需要番茄工作？"></a>1.为什么需要番茄工作？</h4><p> 因为不论工作中或者生活中，总会受到各种各样的打扰或中断，不能专注于自己所做的事，导致工作效率很低，所以我需要一个工作方法来使我更加专注。</p>
<h4 id="2-什么是番茄工作法？"><a href="#2-什么是番茄工作法？" class="headerlink" title="2. 什么是番茄工作法？"></a>2. 什么是番茄工作法？</h4><p>番茄工作法是提高个人工作效率，对自己进行时间管理的工作方法，我认为其实番茄工作法其实是可以和软件开发中的“敏捷开发”来类比的，“敏捷开发”是通过规划、迭代、总结、发挥人的主观能动性来提升团队的工作效率，而番茄工作法也是通过规范、迭代、总结反馈来提高个人的工作效率。</p>
<h4 id="3-怎么使用番茄工作法"><a href="#3-怎么使用番茄工作法" class="headerlink" title="3. 怎么使用番茄工作法?"></a>3. 怎么使用番茄工作法?</h4><p>番茄工作法最重要的工具是番茄钟，番茄工作法将每天的工作时间划分为番茄钟的形式，每25分钟一个番茄钟，当开始番茄钟的时候，即开始进入工作状态，要保证自己在这个番茄钟内专注于一件事，不能被其他的事所打断。每个番茄钟后休息5分钟，每4个番茄钟后可以进行一次大的休息间隙，休息期间不要思考番茄钟内的工作事项，可以去倒水或散步，伸懒腰休息下。每天的晚上进行当日工作的的总结和明日工作的计划，通过自己每天的完成情况来动态的调整自己的工作计划。</p>
<h4 id="4-我的番茄工作法"><a href="#4-我的番茄工作法" class="headerlink" title="4. 我的番茄工作法"></a>4. 我的番茄工作法</h4><p>因为我觉得每日的工作计划不太适合我，所以我将我的工作计划安排为了每周和工作项目的维度来划分，每周来规划自己的工作内容和计划，以番茄钟作为计量单位来规划时间，每周末来进行总结和调整，下面是我的一周的计划的示例，我目前每天可以完成的番茄钟的数目大概在8-10个，所以以下的工作计划目前还是挺难完成的。</p>
<ul>
<li>本周工作计划</li>
</ul>
<table>
<thead>
<tr>
<th>工作项目</th>
<th style="text-align:center">番茄钟个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>读书</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td>练字</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td>健身</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td>工作项目编码</td>
<td style="text-align:center">27</td>
</tr>
<tr>
<td>邮件处理</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>计算机学习</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td>其他</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<ul>
<li>目前使用工具的话，我主要就是使用的番茄钟和电脑软件。番茄钟计时器，是在家里使用，因为在公司不方便使用，所以在公司里我是使用一款叫<a href="http://www.downxia.com/downinfo/45620.html" target="_blank" rel="noopener">做迷你番茄小闹钟</a>的桌面软件来计时的。每周规划因为刚刚开始，暂时是使用excel来管理。</li>
</ul>
<h4 id="5-使用番茄工作法的感受"><a href="#5-使用番茄工作法的感受" class="headerlink" title="5. 使用番茄工作法的感受"></a>5. 使用番茄工作法的感受</h4><p>因为每个人的环境，主观能动性都不一样，使用方式可以随自己的工作习惯来调整，毕竟我们使用工作最主要的目的是提高自己的工作效率，而不是墨守成规的去遵循各种教条。就我个人来说，使用番茄工作法之后工作效率得到了大幅度的提升，尤其是使用番茄闹钟之后，只要番茄闹钟响起，那么就开始了一段激情的工作，25分钟的长度对于我来说也是合适的，不至于太长，坚持不下去，也不至于太短，而阻碍工作的联系性。</p>
<hr>
<ul>
<li>本篇小结总共使用了2个番茄钟来完成，目前每天完成的番茄钟数目太少，需要继续努力，希望可以把每天完成的番茄钟的数目提升到10-12个。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/21/hello-hexo/" itemprop="url">
                  使用hexo和github搭建blog的过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-21T01:10:30+08:00" content="2016-10-21">
              2016-10-21
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/web开发/" itemprop="url" rel="index">
                    <span itemprop="name">web开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/21/hello-hexo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/21/hello-hexo/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/21/hello-hexo/" class="leancloud_visitors" data-flag-title="使用hexo和github搭建blog的过程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>第一篇博客，就以记载我博客搭建的过程来开始吧！</p>
</blockquote>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>安装node环境</li>
</ol>
<ul>
<li>去Node<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>下载最新的Node程序，直接安装即可</li>
</ul>
<ol start="2">
<li>注册github账号 </li>
</ol>
<ul>
<li>去github<a href="https://github.com/" target="_blank" rel="noopener">官网</a>注册即可</li>
</ul>
<ol start="3">
<li>安装git</li>
</ol>
<ul>
<li>安装git来提交内容到github，我这里是直接用的github的<a href="https://desktop.github.com/" target="_blank" rel="noopener">git for Windows客户端软件</a></li>
</ul>
<ol start="4">
<li>安装hexo</li>
</ol>
<ul>
<li><p>新建一个目录blog作为存放博客的目录,打开git shell，进入blog目录下，执行下列命令，安装hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行成功后，再执行下列命令初始化hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行下面的命令来生成静态页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行下列命令即可在本地启动博客</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>看到下面的界面说明本地搭建成功了<br><img src="http://ofejegez5.bkt.clouddn.com/index.png" alt="image"></p>
<h3 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h3><ol>
<li>新建Repository<br>在github新建一个仓库，命名一定要是your_user_name.github.io，新建后仓库如下<br><img src="http://ofejegez5.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20161021003020.png" alt="image"></li>
<li>设置SSH keys</li>
</ol>
<ul>
<li>分别依次执行下列命令，其中邮箱为你github的注册邮箱<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;botale001@163.com&quot;</span><br><span class="line">ssh-agent -s</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ofejegez5.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20161021001556.png" alt="image"><br>到这里后已经生成本地的SSH key数据，打开C:\Users\lightning.ssh\id_rsa.pub文件，拷贝里面的代码到github设置里面的SSH KEY添加。<br><img src="http://ofejegez5.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20161021002110.png" alt="image"></p>
<p>添加完成之后，在本地输入如下命令测试github是否连接成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<p>出现如下结果即表示已经链接成功<br><img src="http://ofejegez5.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20161021002426.png" alt="image"></p>
<ol start="2">
<li>配置hexo</li>
</ol>
<ul>
<li>在你的blog根目录下有个_config.yml文件，该文件为hexo的网站配置文件，打开该文件，修改如下配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:countryboy/countryboy.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中repository的值为即为你的仓库的ssh地址<br><img src="http://ofejegez5.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20161021003020.png" alt="image"><br>至此，已经全部配置完毕，打开git shell，执行如下命令，即可以将你的hexo博客推送到github，以后发布博客，也是使用如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>现在打开域名地址<a href="https://countryboy.github.io/，就可以看到博客了" target="_blank" rel="noopener">https://countryboy.github.io/，就可以看到博客了</a></p>
<h3 id="hexo主题及插件配置"><a href="#hexo主题及插件配置" class="headerlink" title="hexo主题及插件配置"></a>hexo主题及插件配置</h3><ul>
<li>在搭建完成后，可以对博客进行一些个性化的配置，下载一个自己喜欢的主题放在theme目录下，修改根目录下的_config.yml配置文件，修改theme为自己主题的名字，我在这里更换为了一个很简单的主题next，除此之外，你可以可以为博客增加评论和日志统计功能的，具体可以参见<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next主题配置说明</a></li>
</ul>
<h3 id="hexo日志发布"><a href="#hexo日志发布" class="headerlink" title="hexo日志发布"></a>hexo日志发布</h3><ul>
<li>博客最终还是为写日志服务的，hexo写blog都是使用<a href="http://www.appinn.com/markdown/" target="_blank" rel="noopener">markdown</a>语法来写的，写完之后，将博客放_posts在目录下，使用如下命令就可以生成静态网站和发布 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>到目前为止，hexo博客的搭建过程就全部结束，以此作为一个开始，希望我可以坚持写博客^_^!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/actor.jpg" alt="Country boy">
          <p class="site-author-name" itemprop="name">Country boy</p>
          <p class="site-description motion-element" itemprop="description">How many times must a man look up,Before he can see the sky</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives/">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags/">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Country boy</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"countryboy"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("OCXhhvuUszfd9WxkAVBXpg8Q-gzGzoHsz", "tInXTpkeFTOPD1e7SbvAOiRB");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
  


</body>
</html>
